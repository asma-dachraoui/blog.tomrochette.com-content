---
title: The Society of Mind
created: 2015-11-15
taxonomy:
  category: [Artificial General Intelligence]
  status: draft
---

## Context

## Learned in this study

## Things to explore

# Overview

Marvin Minsky's *The Society of Mind* is the epitome of connectionism[^connectionism].

# Thoughts

## Unsorted

* Tasks are executed by low-level, specialized cognitive functions
* The brain is organized hierarchically, where more abstract processes are at the top and low-level functions are at the bottom. In between are *functionalities* that become more and more complex and abstract as they go to the top of the hierarchy
* Higher level functions manage low level functions to ensure they are doing their work properly as well as going in the right direction (doing the *right* thing)
* Higher level functions are competing with one another for resources and being the *main* active process
* Hierarchy of processes
* How are computers different from us?
* They follow instructions
* They don't start things by themselves (do we start things ourselves or if that simply the result of interacting with others?)
* Subconscious -> competing processes that are running in the background

## 7.6 Reinforcement and Reward
* Reward the few moments before success. Works only for short solutions.
* What happens in an architecture with minimal memory? What happens when we gradually increase that memory?
* Only able to execute parts of a big loop
* Procedures encoded as part of a speciesâ€™ genes

## 7.7 Local Responsibility
* Global vs local reward policy/scheme
* Global reward leads to slower learning

## 7.10 Genius
* Genius: knows how to manage what he learns
* Learn to rearrange how to think
* Learn better ways to learn to learn

## 8.1 K-lines: A Theory of Memory
* Tag all the tools that helped you solve a problem
* How do you know which tools to use? Won't you end up taking too many tools? Is it then a question of removing tags from tools that did not contribute to the solution?
* Tags = fragments of ideas

# Notes

## 7.3 The Puzzle Principle
**Puzzle Principle:** We can program a computer to solve anyt problem by trial and error, without knowing how to solve it in advance, provided only that we have a way to recognize the problem is solved.

## 7.4 Problem Solving
**The Progress Principle:** Any process of exhaustive search can be greatly reduced if we possess some way to detect when "progress" has been made. Then we can trace a path toward a solution, just as a person can climb an unfamiliar hill in the dark - by feeling around, at every step, to find the direction of steepest ascent.

**Goals and Subgoals.** The most powerful way we know for discoverying how to solve a hard problem is to find a method that splits it into several simpler ones, each of which can be solved separately.

**Using Knowledge.** The most efficient way to solve a problem is to already know how to solve it. Then one can avoid search entirely.

## 8.1 K-lines: A Theory of Memory
How is knowledge represented?
How is it stored?
How is it retrieved?
Then, how is it used?

## 17.8 Attachment-Images
The Oedipus complex: rejecting one of the two parent models in order to simplify value-model learning.

## 17.9 Different Spans of Memories
* Parent-to-child and child-to-parents bonds based on certain types of memory
* The child (animals) learns through "impriting" to recognize their parents
* The parents (animals) reject children with which they were not involved in bonding shortly after birty; it's an evolutionary disadvantage to raise the offspring of unrelated individuals
* Individuals either bond with a mate "for life" or to certain constant prototypes

## 17.10 Intellectual Trauma
* *I simply can't. I'm just no good at that.*
	* A learned way to avoid the shame and stress that came from social censure of failures in the past
	* It might also be a reaction to the nonsocial sterss that came from having been unable to deal with certain ideas

## 18.1 Must Machines Be Logical?
* A logical system without a goal will merely generate an endless host of pointless truths

## 18.5 Strong Arguments
* Use several different arguments to prove the same point by putting them "in parallel"
* A chain (of arguments) can break with any single injury, but a parallel bundle cannot fail unless every one of its links has been broken

## 18.6 Magnitude from Multitude
**Strength from Magnitude:** When two forces work together, they add to form a single larger force. But when two forces oppose each other directly, their strengths subtract.

**Strength from Multitude:** The more reasons we can find in favor of a particular decision, the more confidence we can have in it. This is because if some of those reasons turn out to be wrong, other reasons may still remain.

## 18.7 What is a Number?
* Every concept is part of a huge network
* Meaning is derived from the network upon which it is built
	* Different for each individual

## 18.8 Mathematics Made Hard
* The more cross-connected our common-sense ideas are, the more useful they're likely to be

## 18.9 Robustness and Recovery
**Duplication:** Duplicate functionality so that if some part of the agents duplicating this functionality are lost, the others can take over.
**Self-Repair:** Be able to repair a faulty section if needed.
**Distributed Processes:** Distribute the function over many area, such that if a portition is destroyed, not all of it is destroyed.
**Accumulation:** Work is based on previous experience, such that if newer experience is lost, we can still proceed from older experience.

# See also

# Sources

* Minsky, Marvin Lee. The Society of Mind. New York: Simon and Schuster, 1986.
* http://www.amazon.com/The-Society-Mind-Marvin-Minsky/dp/0671657135

[^connectionism]: https://en.wikipedia.org/wiki/Connectionism